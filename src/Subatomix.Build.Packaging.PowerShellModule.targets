<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!--
    Copyright 2022 Subatomix Research Inc.

    Permission to use, copy, modify, and distribute this software for any
    purpose with or without fee is hereby granted, provided that the above
    copyright notice and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

  <!--
    This package makes 'dotnet pack' and the Pack command in Visual Studio
    produce a PowerShell module .nupkg suitable for publishing in a repository.

    Import order:
    | project -> SDK .targets -> NuGet package .targets -> Directory.Build.targets
    |                            ^^^^^^^^^here^^^^^^^^^

    REFERENCES

    Customize your build
    https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build

    Common MSBuild project properties
    https://docs.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-properties

    MSBuild well-known item metadata
    https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-well-known-item-metadata

    Item functions
    https://docs.microsoft.com/en-us/visualstudio/msbuild/item-functions?view=vs-2019

    NuGet pack and restore as MSBuild targets
    https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets (specifically, #targetsfortfmspecificcontentinpackage)
    https://github.com/dotnet/sdk/blob/main/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.PackTool.props
    https://github.com/dotnet/sdk/blob/main/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.PackTool.targets

    ResolveToolPackagePaths task
    https://github.com/dotnet/sdk/blob/v3.1.404/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.PackTool.targets
    https://github.com/dotnet/sdk/blob/v3.1.404/src/Tasks/Microsoft.NET.Build.Tasks/ResolveToolPackagePaths.cs
    https://github.com/dotnet/sdk/blob/main/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.PackTool.targets
    https://github.com/dotnet/sdk/blob/main/src/Tasks/Microsoft.NET.Build.Tasks/ResolveToolPackagePaths.cs

    ResolvedFileToPublish property
    https://github.com/dotnet/sdk/blob/main/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.Publish.targets

    Up-to-date check
    https://github.com/dotnet/project-system/blob/main/docs/up-to-date-check.md
    https://github.com/dotnet/project-system/blob/main/src/Microsoft.VisualStudio.ProjectSystem.Managed/ProjectSystem/DesignTimeTargets/Microsoft.Managed.DesignTime.targets
  -->

  <PropertyGroup>
    <IncludeBuildOutput>false</IncludeBuildOutput>

    <!--
      PowerShell modules depend on other PowerShell modules, not on typical
      NuGet packages.  Those module dependencies are specified in .psd1 files
      (aka module manifests).  Dependency DLLs typically ship with the module.
      Thus the .nuspec of the module should not declare any NuGet dependencies.
    -->
    <SuppressDependenciesWhenPacking>true</SuppressDependenciesWhenPacking>

    <!--
      PowerShell module files should appear at the root of the package.
    -->
    <ContentTargetFolders>.</ContentTargetFolders>

    <!--
      Turn off warnings complaining that the module is not structured like a
      typical .NET NuGet package.  They do not apply to PowerShell modules.

      NU5100: The assembly '...' is not inside the 'lib' folder and hence it
              won't be added as a reference when the package is installed into
              a project. Move it into the 'lib' folder if it needs to be
              referenced.

      NU5110: The script file '...' is outside the 'tools' folder and hence
              will not be executed during installation of this package. Move
              it into the 'tools' folder.

      NU5111: The script file '...' is not recognized by NuGet and hence will
              not be executed during installation of this package. Rename it
              to install.ps1, uninstall.ps1 or init.ps1 and place it directly
              under 'tools'.
    -->
    <NoWarn>$(NoWarn);NU5100;NU5110;NU5111</NoWarn>

    <CoreBuildDependsOn>
      GeneratePsd1;
      $(CoreBuildDependsOn)
    </CoreBuildDependsOn>

    <TargetsForTfmSpecificContentInPackage>
      $(TargetsForTfmSpecificContentInPackage);
      ConfigurePackModule
    </TargetsForTfmSpecificContentInPackage>

    <ConfigurePackModuleDependsOn>
      ConfigurePackDepsFile;<!-- .NET Core 3.1 SDK and earlier -->
      ConfigurePackPublishedFile;
      $(ConfigurePackModuleDependsOn)
    </ConfigurePackModuleDependsOn>
  </PropertyGroup>

  <ItemDefinitionGroup>
    <Content>
      <!--
        This package tracks PowerShell files (.ps1, .psm1, ...) as Content
        items.  Copy them to the output and publish directories so that the
        file layout at F5 run approximates that of the installed module.
      -->
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>

      <!--
        This package configures the build to pack all published items.  To
        avoid duplicates, undo the pack-by-default 
      -->
      <Pack>false</Pack>
    </Content>
  </ItemDefinitionGroup>

  <ItemGroup>
    <!-- Prevent PowerShell files from being duplicated as None items -->
    <None Remove="$(PowerShellItemIncludes)"/>

    <!-- Nest generated .psd1 files under their templates -->
    <Content Update="**\*.psd1">
      <DependentUpon Condition="Exists('%(Identity).t')">%(Filename)%(Extension).t</DependentUpon>
    </Content>
  </ItemGroup>

  <!-- Trigger rebuild if generated .psd1 files are missing or outdated -->
  <Target Name="Psd1CollectUpToDateCheckBuiltDesignTime" BeforeTargets="CollectUpToDateCheckBuiltDesignTime" >
    <ItemGroup>
      <UpToDateCheckBuilt Include="%(Psd1Template.RecursiveDir)%(Psd1Template.Filename)">
        <Original>%(Psd1Template.RecursiveDir)%(Psd1Template.Filename)%(Psd1Template.Extension)</Original>
      </UpToDateCheckBuilt>
    </ItemGroup>
  </Target>

  <Target Name="GeneratePowerShellItemLists"
          BeforeTargets="GeneratePsd1">
    
    <PropertyGroup>
      <PowerShellScriptFiles>@(PowerShellScript->'%(Quoted)', ', ')</PowerShellScriptFiles>
      <PowerShellScriptModuleFiles>@(PowerShellScriptModule->'%(Quoted)', ', ')</PowerShellScriptModuleFiles>
      <PowerShellModuleManifestFiles>@(PowerShellModuleManifest->'%(Quoted)', ', ')</PowerShellModuleManifestFiles>
      <PowerShellFormatFiles>@(PowerShellFormat->'%(Quoted)', ', ')</PowerShellFormatFiles>
      <PowerShellTypeFiles>@(PowerShellType->'%(Quoted)', ', ')</PowerShellTypeFiles>
      <PowerShellSessionFiles>@(PowerShellSession->'%(Quoted)', ', ')</PowerShellSessionFiles>
      <PowerShellRoleFiles>@(PowerShellRole->'%(Quoted)', ', ')</PowerShellRoleFiles>
      <PowerShellCIMCmdletFiles>@(PowerShellCIMCmdlet->'%(Quoted)', ', ')</PowerShellCIMCmdletFiles>
      <PowerShellHelpFiles>@(PowerShellHelp->'%(Quoted)', ', ')</PowerShellHelpFiles>
      <PowerShellFiles>@(PowerShell->'%(Quoted)', ', ')</PowerShellFiles>
    </PropertyGroup>

    <ItemGroup>
      <Psd1Replacement Include="PowerShellScriptFiles">
        <Value>$(PowerShellScriptFiles)</Value>
      </Psd1Replacement>
      <Psd1Replacement Include="PowerShellScriptModuleFiles">
        <Value>$(PowerShellScriptModuleFiles)</Value>
      </Psd1Replacement>
      <Psd1Replacement Include="PowerShellModuleManifestFiles">
        <Value>$(PowerShellModuleManifestFiles)</Value>
      </Psd1Replacement>
      <Psd1Replacement Include="PowerShellFormatFiles">
        <Value>$(PowerShellFormatFiles)</Value>
      </Psd1Replacement>
      <Psd1Replacement Include="PowerShellTypeFiles">
        <Value>$(PowerShellTypeFiles)</Value>
      </Psd1Replacement>
      <Psd1Replacement Include="PowerShellSessionFiles">
        <Value>$(PowerShellSessionFiles)</Value>
      </Psd1Replacement>
      <Psd1Replacement Include="PowerShellRoleFiles">
        <Value>$(PowerShellRoleFiles)</Value>
      </Psd1Replacement>
      <Psd1Replacement Include="PowerShellCIMCmdletFiles">
        <Value>$(PowerShellCIMCmdletFiles)</Value>
      </Psd1Replacement>
      <Psd1Replacement Include="PowerShellHelpFiles">
        <Value>$(PowerShellHelpFiles)</Value>
      </Psd1Replacement>
      <Psd1Replacement Include="PowerShellFiles">
        <Value>$(PowerShellFiles)</Value>
      </Psd1Replacement>

      <Psd1Replacement Update="@(Psd1Replacement)" Name="%(Identity)" />
    </ItemGroup>

  </Target>

  <Target Name="GeneratePsd1PropertiesFile"
          Inputs="@(Psd1Template);@(Psd1ReplacementProperty)"
          Outputs="$(IntermediateOutputPath)$(GeneratedPropertyImportFile)">
    <PropertyGroup>
      <_FileHeader>
<![CDATA[
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <ItemGroup>]]>
      </_FileHeader>
      <_FileFooter>
<![CDATA[  </ItemGroup>
</Project>
]]>
      </_FileFooter>

        <_ReplacementItemHeaderOpen><![CDATA[    <Psd1Replacement Include="]]></_ReplacementItemHeaderOpen>
        <_ReplacementItemHeaderClose><![CDATA[">
]]></_ReplacementItemHeaderClose>
        <_ReplacementItemNameOpen><![CDATA[      <Name>]]></_ReplacementItemNameOpen>
        <_ReplacementItemNameClose><![CDATA[</Name>
]]></_ReplacementItemNameClose>
        <!--Value>$([MSBuild]::ValueOrDefault(%(Value), ''))</Value-->
        <_ReplacementItemValueOpen><![CDATA[      <Value>]]></_ReplacementItemValueOpen>
        <_ReplacementItemValueClose><![CDATA[</Value>
]]></_ReplacementItemValueClose>
        <_ReplacementItemFooter><![CDATA[    </Psd1Replacement>]]></_ReplacementItemFooter>
    </PropertyGroup>

    <PropertyGroup>
      <GeneratedPropertyImportFileFullPath>$(MSBuildProjectDirectory)\$(IntermediateOutputPath)$(GeneratedPropertyImportFile)</GeneratedPropertyImportFileFullPath>
    </PropertyGroup>

    <!-- Generate the Value metadata of the Psd1ReplacementProperty items, since we can't define it in the ItemDefinitionGroup. -->
    <!-- MSBuild puts the literal text %(Identity) instead of the value of %(Identity) as opposed to defining it in te actual item declaration -->
    <ItemGroup>
      <Psd1ReplacementProperty Update="@(Psd1ReplacementProperty)" Condition="'%(Value)' == ''">
        <Value>$([System.String]::Concat('$(', %(Identity), ')'))</Value>
      </Psd1ReplacementProperty>
    </ItemGroup>

    <ItemGroup>
      <Psd1ReplacementText Include="@(Psd1ReplacementProperty->'$(_ReplacementItemHeaderOpen)%(Name)$(_ReplacementItemHeaderClose)$(_ReplacementItemNameOpen)%(Name)$(_ReplacementItemNameClose)$(_ReplacementItemValueOpen)%(Value)$(_ReplacementItemValueClose)$(_ReplacementItemFooter)')" />
    </ItemGroup>

    <WriteLinesToFile File="$(GeneratedPropertyImportFileFullPath)" Lines="$(_FileHeader);@(Psd1ReplacementText);$(_FileFooter)" Overwrite="true"/>
    
  </Target>

  <!-- Generate .psd1 files from the .psd1.t templates -->
  <Target Name="GeneratePsd1"
          Condition="'$(DesignTimeBuild)' != 'true'"
          BeforeTargets="AssignTargetPaths" 
          DependsOnTargets="GeneratePsd1PropertiesFile"
          Inputs="@(Psd1Template);$(GeneratedPropertyImportFileFullPath)" Outputs="@(Psd1Template->'%(RecursiveDir)%(Filename)')">

    <!-- We need to invoke an external instance of MSBuild, since there is no simple way to access property values programatically from reflection. -->
    <!-- We'll override some key properties so that this new instance can have a very similar set of properties to the current running build. -->
    <ItemGroup>
      <_OverrideProperty Include="GeneratedPropertyImportFile=$(GeneratedPropertyImportFileFullPath)" />
      <_OverrideProperty Include="Configuration=$(Configuration)" />
      <_OverrideProperty Include="Platform=$(Platform)" />
    </ItemGroup>

    <MSBuild 
      Projects="$(MSBuildProjectFullPath)"
      Targets="GeneratePsd1File"
      Properties="@(_OverrideProperty)"
      RebaseOutputs="true">
      <Output TaskParameter="TargetOutputs" ItemName="GeneratedPsd1"/>
    </MSBuild>

    <ItemGroup>
      <!-- Enlist generated file to be removed on next Clean. -->
      <FileWrites Include="@(GeneratedPsd1)" />

      <!-- Add generated file as a Content item, so it gets copied to output. -->
      <Content Include="@(GeneratedPsd1)" Exclude="@(Content)">
        <DependentUpon>%(RecursiveDir)%(Filename)%(Extension).t</DependentUpon>
      </Content>
    </ItemGroup>
  </Target>

  <!-- This is the file that is generated by the PowershellModule targets and has the generated properties used for substitution -->
  <Import Project="$(GeneratedPropertyImportFile)" Condition="Exists($(GeneratedPropertyImportFile))"/>

  <UsingTask TaskName="ReplacePropertiesInFile" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <Files ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <CopyToOutputDirectory />
      <Extension />
      <Properties ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true"/>
      <Result ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.Text.RegularExpressions" />
      <Using Namespace="System.Linq" />
      <Code Type="Fragment" Language="cs">
<![CDATA[
        string regex = @"(?<=[^\$@])\{(?<Property>[A-Za-z0-9]+)\}";
        if (Files.Length > 0)
        {
          // Transform the properties into a dictionary
          var properties = Properties.ToDictionary(prop => prop.GetMetadata("Name"), prop => prop.GetMetadata("Value"));

          Log.LogMessage(MessageImportance.Low, "Properties to use for replacement:");

          foreach(var prop in properties)
          {
            Log.LogMessage(MessageImportance.Low, $"\t{prop.Key} = {prop.Value}");
          }

          Hashtable metadata = new Hashtable();
          if(!string.IsNullOrEmpty(CopyToOutputDirectory))
          {
            metadata.Add("CopyToOutputDirectory", CopyToOutputDirectory);
          }

          Result = new TaskItem[Files.Length];
          uint i = 0;
          foreach (ITaskItem file in Files)
          {
            string filePath = file.GetMetadata("FullPath");
            string rootDir = file.GetMetadata("RootDir");
            string recursiveDir = file.GetMetadata("Directory");
            string fileName = file.GetMetadata("Filename");
            string newFilePath = rootDir + recursiveDir + fileName + Extension;

            Log.LogMessage(MessageImportance.Low, $"Replacing MSBuild Properties in file: {filePath}");

            using (StreamReader reader = File.OpenText(filePath))
            {
              string newFileContents = Regex.Replace(
                reader.ReadToEnd(),
                regex,
                (match) => {
                  string propertyName = match.Groups["Property"].Value;
                  string propertyValue = properties.ContainsKey(propertyName) ? properties[propertyName] : string.Empty;
                  Log.LogMessage(MessageImportance.Low, $"Replacing property: Name<{propertyName}> Value<{propertyValue}>");
                  return propertyValue;
                }
              );

              Log.LogMessage(MessageImportance.Low, $"Writing replaced MSBuild properties to: {newFilePath}");

              using (StreamWriter writer = new StreamWriter(newFilePath))
              {
                writer.Write(newFileContents);
              }

              Result[i++] = new TaskItem(newFilePath, metadata);
            }
          }
        }
]]>
      </Code>
    </Task>
  </UsingTask>

  <Target Name="GeneratePsd1File"
          DependsOnTargets="GeneratePowerShellItemLists"
          Returns="@(GeneratedPsd1)">
    
    <ReplacePropertiesInFile Files="@(Psd1Template)" 
                             Properties="@(Psd1Replacement)"
                             CopyToOutputDirectory="PreserveNewest">
      <Output ItemName="GeneratedPsd1" TaskParameter="Result" />
    </ReplacePropertiesInFile>

    <ItemGroup>
      <GeneratedPsd1 Update="@(GeneratedPsd1)">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      </GeneratedPsd1>
    </ItemGroup>
    

  </Target>


  <!-- _CleanGetCurrentAndPriorFileWrites does not count any files outside of IntermediateDir or OutputDir. -->
  <!-- We must manually add the generated Psd1 to _CleanCurrentFileWrites so it can be properly cleaned -->
  <Target Name="_CleanAddGeneratedPsd1" 
    AfterTargets="_CleanGetCurrentAndPriorFileWrites"
    BeforeTargets="IncrementalClean">

    <ItemGroup>
      <_CleanCurrentFileWrites Include="@(GeneratedPsd1)" />
    </ItemGroup>
  </Target>

  <!-- CoreClean explicitly does not clean items outside of IntermediateDir or OutputDir. -->
  <!-- We must manually clean those files in oun own target. -->
  <Target Name="_CleanRemainingItems"
    AfterTargets="CoreClean">

    <Delete
      Files="@(_CleanUniqueRemainingFileWrites);$(IntermediateOutputPath)$(CleanFile)" 
      TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_CleanPriorFileWritesDeleted" />
    </Delete>

  </Target>

  <Target Name="ConfigurePackModule" DependsOnTargets="$(ConfigurePackModuleDependsOn)" />

  <Target Name="ConfigurePackDepsFile" DependsOnTargets="PublishForPack"
          Condition="$([MSBuild]::VersionLessThan($(NETCoreSdkVersion), 5.0))">
    <ItemGroup>
      <_DepsFile Include="$(PublishDepsFilePath)"/>
    </ItemGroup>
    <ItemGroup>
      <TfmSpecificPackageFile Include="@(_DepsFile)">
        <PackagePath></PackagePath>
      </TfmSpecificPackageFile>
    </ItemGroup>
  </Target>

  <Target Name="ConfigurePackPublishedFile"
          DependsOnTargets="
            _ConfigurePackPublishedFilesNetCore;
            _ConfigurePackPublishedFilesSinceNet5
          ">
    <ItemGroup>
      <!-- Remove 'tools/all/any/' prefix (length 14) from package paths -->
      <TfmSpecificPackageFile Include="@(_ResolvedFileToPublishWithPackagePath)">
        <PackagePath>$([System.String]::Copy('%(_ResolvedFileToPublishWithPackagePath.PackagePath)').Substring(14))</PackagePath>
      </TfmSpecificPackageFile>
    </ItemGroup>
  </Target>

  <Target Name="_ConfigurePackPublishedFilesNetCore" DependsOnTargets="PublishForPack"
          Condition="$([MSBuild]::VersionLessThan($(NETCoreSdkVersion), 5.0))">
    <ResolveToolPackagePaths ResolvedFileToPublish="@(ResolvedFileToPublish)"
                             PublishDir="$(PublishDir)"
                             TargetFramework="all">
      <Output TaskParameter="ResolvedFileToPublishWithPackagePath"
              ItemName="_ResolvedFileToPublishWithPackagePath" />
    </ResolveToolPackagePaths>
  </Target>

  <Target Name="_ConfigurePackPublishedFilesSinceNet5" DependsOnTargets="PublishForPack"
          Condition="$([MSBuild]::VersionGreaterThanOrEquals($(NETCoreSdkVersion), 5.0))">
    <ResolveToolPackagePaths ResolvedFileToPublish="@(ResolvedFileToPublish)"
                             PublishDir="$(PublishDir)"
                             TargetFrameworkMoniker="all">
      <Output TaskParameter="ResolvedFileToPublishWithPackagePath"
              ItemName="_ResolvedFileToPublishWithPackagePath" />
    </ResolveToolPackagePaths>
  </Target>

  <!--
    NOTE: Broken when using Pack target and GeneratePackageOnBuild=true.
          Set GeneratePackageOnBuild=false or use Build target instead.
  -->
  <Target Name="PublishForPack"
          DependsOnTargets="_PublishForPackBuild;_PublishForPackNoBuild"
          Condition="'$(IsPublishable)' == 'true'">
    <Message Importance="High"
             Text="$(MSBuildProjectName) -> $([System.IO.Path]::GetFullPath('$(PublishDir)'))" />
  </Target>

  <Target Name="_PublishForPackBuild"
          DependsOnTargets="_PublishBuildAlternative"
          Condition="'$(GeneratePackageOnBuild)' != 'true' And '$(NoBuild)' != 'true'" />

  <Target Name="_PublishForPackNoBuild"
          DependsOnTargets="$(_PublishNoBuildAlternativeDependsOn)"
          Condition="'$(GeneratePackageOnBuild)' == 'true' Or '$(NoBuild)' == 'true'" />

</Project>
